h1(#chapter:mapping). Mapping

One of the essential steps during embedded software development for multi&#45;core platforms is the mapping from elements of the software to elements of the hardware, e.g. @Tasks@ to @Schedulers@, @Labels@ to @Memorys@ etc. This is usually a non trivial task, as an infinite number of combinations arises if either the software or the hardware becomes very complex. The purpose of AMALTHEAs Mapping Plugin is to determine such a mapping and store it in a _*Mapping Model*_ which will contain the allocations of elements of the _*Software Model*_ to elements of the _*Hardware Model*_.

h2(#sec:mapConcept). Concept

The conceptual implementation of AMALTHEAs Mapping Plugin is shown in the following Figure. 

!{width:100.0%;height:auto;}../pictures/mapping/MappingToolConcept.png(Concept of the AMALTHEAs Mapping Plugin)!

As shown in the top of this figure, it requires several models to operate. The models for *Software*, *Hardware* and *Constraints* are mandatory while the *Property Constraints* Model is optional.

Using AMALTHEAs Mapping Plugin, the user is able to choose between different mapping strategies. Currently these strategies are split into two categories: _Heuristic methods_ and _Integer Linear Programming (ILP) based methods_. Unlike ILP based methods, Heuristic methods, such as the _Heuristic Data Flow Graph (DFG) load balancing_, will immediately create a mapping.

ILP based methods on the other hand will first need to generate an ILP model of the mapping problem according to the selected mapping strategy, e.g. _ILP based load balancing_ or _Energy aware mapping_. Once the ILP model has been created, it will be solved by one of the mathematical _Solvers_. Currently, the open source project Oj!Algo[1] has been used in AMALTHEAs Mapping Plugin. Furthermore, the user can activate an optional MPS generator, which will generate an MPS file containing the ILP problem. This file may be used to solve the ILP problem by external (e.g. commercial) solvers, which tend to be more efficient in solving larger models compared to open source Java implementations.

Once a mapping has been determined, it is displayed within the eclipse console and following output models are generated:

* *Mapping Model*, containing the allocations from @Tasks@ to @Schedulers@
* *OS Model*, containing the @Schedulers@ for each @Core@
* *Stimuli Model*, containing the @Stimuli@ for the resp. @Runnable@ and @Task@ activations




