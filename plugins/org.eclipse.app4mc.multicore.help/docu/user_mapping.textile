h2(#chapter:mapping). Mapping

One of the essential steps during embedded software development for multi&#45;core platforms is the mapping from elements of the software to elements of the hardware, e.g. @Tasks@ to @Schedulers@, @Labels@ to @Memorys@ etc. This is usually a non trivial task, as an infinite number of combinations arises if either the software or the hardware becomes very complex. The purpose of AMALTHEAs Mapping Plugin is to determine such a mapping and store it in a _*Mapping Model*_ which will contain the allocations of elements of the _*Software Model*_ to elements of the _*Hardware Model*_.

h3(#sec:mapConcept). Concept

The conceptual implementation of AMALTHEAs Mapping Plugin is shown in the following Figure. 

!{width:75.0%;height:auto;}../pictures/mapping/MappingToolConcept.png(Concept of the AMALTHEAs Mapping Plugin)!

As shown in the top of this figure, it requires several models to operate. The models for *Software*, *Hardware* and *Constraints* are mandatory while the *Property Constraints* Model is optional.

Using AMALTHEAs Mapping Plugin, the user is able to choose between different mapping strategies. Currently these strategies are split into two categories: _Heuristic methods_ and _Integer Linear Programming (ILP) based methods_. Unlike ILP based methods, Heuristic methods, such as the _Heuristic Data Flow Graph (DFG) load balancing_, will immediately create a mapping.

ILP based methods on the other hand will first need to generate an ILP model of the mapping problem according to the selected mapping strategy, e.g. _ILP based load balancing_ or _Energy aware mapping_. Once the ILP model has been created, it will be solved by one of the mathematical _Solvers_. Currently, the open source project Oj!Algo[1] has been used in AMALTHEAs Mapping Plugin. Furthermore, the user can activate an optional MPS generator, which will generate an MPS file containing the ILP problem. This file may be used to solve the ILP problem by external (e.g. commercial) solvers, which tend to be more efficient in solving larger models compared to open source Java implementations.

Once a mapping has been determined, it is displayed within the eclipse console and following output models are generated:

* *Mapping Model*, containing the allocations from @Tasks@ to @Schedulers@
* *OS Model*, containing the @Schedulers@ for each @Core@
* *Stimuli Model*, containing the @Stimuli@ for the resp. @Runnable@ and @Task@ activations

h3(#sec:mapImplementation). Implementation

The following subsections give a short introduction about the different algorithm implementations of AMALTHEAs Mapping Plugin. Section "Task generation":#sec:mapTaskGen describes the task generation method which is used to convert process prototypes into tasks. It is meant to be used by mapping algorithms which do not feature task generation by themselves. Sections "Mapping Strategy 1: Heuristic DFG load balancing":#sec:mapLoadBalDFG and "Mapping Strategy 2: ILP based load balancing":#sec:mapLoadBalILP describe a heuristic and a mathematical load balancing approach for mapping of tasks to cores. Last but not least, a more complex method for energy efficient task mapping with its own task creation algorithm is outlined in section "Mapping Strategy 3: Minimizing Energy Consumption":#sec:mapEnergy.

h4(#sec:mapTaskGen). Task generation

The task generation method in AMALTHEAs Mapping Plugin is a pragmatic way to create tasks for other mapping algorithms which require @Tasks@, i.e. are not designed to agglomerate @Runnables@ into @Tasks@ on their own. This step utilizes @ProcessPrototypes@ which are generated by the partitioning plugin (see Chapter *Partitioning*) and transforms them into @Tasks@. Furthermore, it will also create the *_Stimuli Model_* which contains the activation elements for the @Tasks@, i.e. @Periodic@. An overview about the transformed elements and their sources as well as destinations is shown in "Table 1":#tab:table1.

p<(#tab:table1). 

|_. Source Model|_. Source Element|_. Target Model|_. Target Element|
| SW| ProcessPrototype| SW| Task|
| SW| Activation| Stimuli| Stimulus|
| Constraints| ProcessRunnableGroupEntry| SW| TaskRunnableCall|

p=. Table 1

h4(#sec:mapLoadBalDFG). Mapping Strategy 1: Heuristic DFG load balancing

The _Heuristic Data Flow Graph (DFG) load balancing_ algorithm aims at achieving an equal utilization of a hardware platforms cores for DFG based software models.

The first step in this algorithm is to determine the most complex @Task@ (usually representing the critical path) and allocate it to the best fit core of a hardware platform. The runtime for each @Task@ will now be estimated for every @Core@ within the @System@ and allocated to a @Core@ which has the smallest increase of the longest overall runtime within all cores.

One of the major benefits of this algorithm is its very low runtime. The information which is processed by this mapping strategy and, as such, has to be present in the input models, is shown in table [tab:mapLoadBalILP].

h4(#sec:mapLoadBalILP). Mapping Strategy 2: ILP based load balancing

A comparatively simple ILP based strategy to allocate tasks to processors while minimizing the total execution time is presented in . This method supports multiple processors with the same processing speed (e.g. homogeneous processors) and it does not consider any dependencies between the tasks (e.g. waiting for the results of the predecessor).

As described by the author, load balancing within this method is achieved by minimizing the highest execution duration <span class="math">C_{max}</span> of all <span class="math">m</span> processing units with <span class="math">n</span> tasks (see eq. [eq:evalIlpLoadBalanceMin] and [eq:evalIlpLoadBalanceSubject]). The variable <span class="math">x_{ij}</span> is set to <span class="math">1</span> if a task <span class="math">j</span> is allocated to processor <span class="math">i</span> and <span class="math">0</span> otherwise. Eq. [eq:evalIlpLoadBalanceLimit] guarantees that each task is allocated to exactly one processor while [eq:evalIlpLoadBalanceInteger] limits variables <span class="math">x_{ij}</span> type to boolean values. The duration of a task <span class="math">j</span> is specified by <span class="math">p_{j}</span>.

<span class="math">\begin{aligned}
{2}
&amp; \text{minimize} &amp; &amp; C_{max}
\label{eq:evalIlpLoadBalanceMin} \\
&amp; \text{subject to} \quad &amp; &amp; \sum_{j=1}^{n}x_{ij}p_j \leq C_{max}, \; i = 1, \ldots, n
\label{eq:evalIlpLoadBalanceSubject} \\
&amp; &amp; &amp; \sum_{i=1}^{m}x_{ij}=1, \; j = 1, \ldots, n
\label{eq:evalIlpLoadBalanceLimit} \\
&amp; &amp; &amp; x_{ij} \in {0,1}
\label{eq:evalIlpLoadBalanceInteger}\end{aligned}</span>

One of the downsides in this algorithm is caused by <span class="math">p_{j}</span> in eq. [eq:evalIlpLoadBalanceSubject] which forces an equal processing duration of a task <span class="math">j</span> on all cores. It is however possible to expand the method to support heterogeneous processors (in this case: processors with different processing speeds) with a minor modification[2]: replacing <span class="math">p_{j}</span> with <span class="math">p_{ij}</span>, i.e. a separate processing duration of task <span class="math">j</span> for every core <span class="math">i</span>, will solve this problem.

The minimal amount of information which is required to execute this algorithm is outlined in Table [tab:mapLoadBalILP].

h4(#sec:mapEnergy). Mapping Strategy 3: Minimizing Energy Consumption

This mapping algorithm is based on the work _"Task Scheduling and Voltage Selection for Energy Minimization"_ from Zhang et al. which presents a framework which aims at minimizing the energy consumption of variable voltage processors executing real time dependent tasks. This method is implemented as a two phase approach which integrates

* *Task assignment*: allocating each task to a core
* *Task ordering*: ordering the tasks in due consideration of their constraints and deadlines
* *Voltage selection*: selecting a slower but less energy consuming processor mode in order to save energy without harming any constraints or deadlines

In the first phase, opportunities for energy minimization are revealed by ordering real&#45;time dependent tasks and assigning them to processors on the respective target platform.

* On *single processor platforms*, the ordering of tasks is performed by applying an Earliest Deadline First (EDF) scheduling. An further allocation of tasks to processors becomes needless, as only one allocation target exists.
* On *multi processor platforms*, a priority based task ordering is performed. The allocation of tasks to processors is determined by a best fit processor assignment.

Once the scheduling is created, there will be time frames between the end of one task and the start of another during which the processor is not being utilized (so called slacks). These slacks the prerequisites for the second phase, which performs the voltage selection. This phase aims at determining the resp. (optimal) processor voltage for each of its task executions without harming the constraints and eventually minimizing the total energy consumption of the system. In order to determine these voltages, the task scheduling is transformed into a directed acyclic graph (DAG) that is used to model the selection problem as integer programming (IP) problem. Once the model has been set up, it is optimized by a mathematical solver.

This algorithm has been implemented with two constraints:

* Only multi&#45;core systems may be chosen as target platform, single core is not supported.
* The algorithm is not meant to be used on heterogeneous cores, i.e. only multiple instances of the same type of core are supported.

Table [tab:mapEnergy] lists the minimal amount of information which has to be present in the input models in order for this mapping strategy to work as well the special annotations which are added to the mapping model.


h3(#sec:mapUtilization). Utilization of the AMALTHEAs Mapping Plugin

This section provides information on the utilization of the AMALTHEA Mapping Plugin, i.e. its configuration (section [sec:mapConfiguration]) and how to generate mappings (section [sec:mapCreateMapping]).

h4(#sec:mapConfiguration). Configuration and Preferences

!{width:95.0%;height:auto;}MappingPreferences.png(AMALTHEA Mapping Plugin's Preferences Page)!
AMALTHEA Mapping Plugin's Preferences Page

The configuration of AMALTHEAs Mapping Plugin can be performed through its preferences page (see Figure [fig:mapPreferences]). It is integrated into the AMALTHEA Tool Platform and can be accessed through the menu bar under 'Window' <span class="math">\rightarrow</span> 'Preferences' <span class="math">\rightarrow</span> 'AMALTHEA Mapping'. The configurable fields, their types and their descriptions are listed below.

h4(#enabling-verbose-logging). Enabling verbose logging

Checking the box *_'Enable verbose logging to console'_* will enable verbose logging to stdout. This may help to identify problems if the mapping plugin should fail to generate a mapping.

h4(#specifying-the-output-location). Specifying the output location

The radio buttons under *_'Select output location'_* allow to customize the directory which where newly generated files will be placed into.

<ul>
<li><p>*Default location* specifies the 'output' directory within the respective projects root folder as destination for all new generated files.</p></li>
<li><p>*Custom location (relative to project root)* will ensure that all new files are created in a custom directory of the respective projects root folder. The name of this custom directory can be customized by changing the value in the text field below the radio buttons.</p></li>
<li><p>*Custom location (absolute path)* allows the user to specify a full custom destination for new generated files. The destination can be specified by either changing the value of the text field below the radio buttons, or by using the "Select" button.</p>
<p>_Hint: It should be noted, that using this option will NOT update the project explorers folder list once the mapping is finished. It should be avoided to use this option in combination with a target location within the eclipse workspace._</p></li>
</ul>

h4(#selecting-a-mapping-algorithm). Selecting a mapping algorithm

The radio buttons within *_'Select mapping algorithm'_* allow to customize the mapping strategy which should be applied during the mapping process. Currently, there are three valid options:

* *Load balancing for DFG*, described in section [sec:mapLoadBalDFG]
* *ILP based load balancing*, described in section [sec:mapLoadBalILP]
* *Energy efficient mapping*, described in section [sec:mapEnergy]

h4(#configuring-mathematical-solver). Configuring Mathematical Solver

_Hint: The settings described in this section only affect ILP based algorithms!_

The section *_Solver Settings_* allows to configure the solver which is used to approximate the ILP problems, specify the minimal accuracy of the found solution and activate the MPS file output of the &#45; ready to solve &#45; ILP problem.

* *Generate MPS file* will activate MPS file generation. The resulting MPS file will contain the actual ILP problem for the chosen mapping strategy.
* *Max. Gap* specifies the maximal gap (percentage) between the LP relaxion and a feasible solution before the solver considers it to be optimal.
Setting this value to 0.0 will order to solver to continue until either the final solution reaches the same value as the LP relaxion or another limit (below) has been reached while 1.0 will consider the first feasible solution being optimal.
_Valid values: <span class="math">0.0 - 1.0</span>_

Furthermore, it is possible to specify the maximum number of iterations or time spend on finding an optimal solution.

* *Max. Iterations (Abort)* specifies the maximal *_total_* number of iterations which may be performed by the approximation algorithm in order to find an optimal solution for the ILP problem.
* *Max. Time (Abort)* specifies the maximal *_total_* amount of time (milliseconds) that may be spend by the approximation algorithm in order to find an optimal solution for the ILP problem.
* *Max. Iteration (Suffice)* specifies the maximal number of iterations which may be performed by the approximation algorithm in order to *_improve_* a previously found feasible solution.
* *Max. Time (Suffice)* specifies the maximal amount of time (milliseconds) that may be spend by the approximation algorithm in order to *_improve_* a previously found feasible solution.

Setting one of these values to zero will pass the value of INT&#95;MAX to the solver, technically removing the respective constraint.

h4(#sec:mapCreateMapping). Generating a mapping

Depending on the selected mapping strategy, it may be required to create tasks in advance of the mapping algorithm. The method *'Create Tasks'*, which is accessible through the _AMALTHEA Software Models_ file context menu (right click on _<span class="math">\ast</span>.amxmi_ and _<span class="math">\ast</span>.amxmi&#45;sw_ files), is capable of transforming partitioned[3] software models into software models with tasks.

The mapping can be performed once input models with the required amount of information are present[4]. Opening the context menu again (right click on _<span class="math">\ast</span>.amxmi_ and _<span class="math">\ast</span>.amxmi&#45;sw_ files) and selecting *'Perform Mapping'* will open the 'Perform Mapping GUI' (see Figure [fig:mapGUI]).

!{width:95.0%;height:auto;}MappingGUI.png(Perform Mapping GUI)!
Perform Mapping GUI

The fields within the GUI are described below.

* *Name of the Project* is automatically filled and based on the selected software model. This value is used to specify the base name of the output files and may be customized.
* *Path to Software Model* points to the location of the file containing the AMALTHEA Software Model which will be used during the mapping process. This path is automatically set, but may be changed if desired.
* *Path to Hardware Model* points to the location of the file containing the AMALTHEA Hardware Model which will be used during the mapping process.


fn1. Oj!Algorithms, licensed under the MIT license, see: http://ojalgo.org


fn2. Mentioned, among others, in 


fn3. A detailed guide on partitioning a model is available in Chapter [chapter:partitioning]


fn4. see section [sec:mapImplementation] for detailed information about the mapping strategies and their required amount of information
