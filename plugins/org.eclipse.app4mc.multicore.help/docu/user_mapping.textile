h2(#chapter:mapping). Mapping

One of the essential steps during embedded software development for multi&#45;core platforms is the mapping from elements of the software to elements of the hardware, e.g. @Tasks@ to @Schedulers@, @Labels@ to @Memorys@ etc. This is usually a non trivial task, as an infinite number of combinations arises if either the software or the hardware becomes very complex. The purpose of APP4MCs OpenMapping Plugin is to determine such a mapping and store it in a _*Mapping Model*_ which will contain the allocations of elements of the _*Software Model*_ to elements of the _*Hardware Model*_.

h3(#sec:mapConcept). Concept

The conceptual implementation of OpenMapping Plugin is shown in the following Figure. 

!{width:75.0%;height:auto;}../pictures/mapping/MappingToolConcept.png(Concept of the OpenMapping Plugin)!

As shown in the top of this figure, it requires several models to operate. The models for *Software*, *Hardware* and *Constraints* are mandatory while the *Property Constraints* Model is optional.

Using the OpenMapping Plugin, the user is able to choose between different mapping strategies. Currently these strategies are split into two categories: _Heuristic methods_ and _Integer Linear Programming (ILP) based methods_. Unlike ILP based methods, Heuristic methods, such as the _Heuristic Data Flow Graph (DFG) load balancing_, will immediately create a mapping.

ILP based methods on the other hand will first need to generate an ILP model of the mapping problem according to the selected mapping strategy, e.g. _ILP based load balancing_ or _Energy aware mapping_. Once the ILP model has been created, it will be solved by one of the mathematical _Solvers_. Currently, the open source project Oj!Algo[1] has been used in OpenMapping Plugin. Furthermore, the user can activate an optional MPS generator, which will generate an MPS file containing the ILP problem. This file may be used to solve the ILP problem by external (e.g. commercial) solvers, which tend to be more efficient in solving larger models compared to open source Java implementations.

Once a mapping has been determined, it is displayed within the eclipse console and following output models are generated:

* *Mapping Model*, containing the allocations from @Tasks@ to @Schedulers@
* *OS Model*, containing the @Schedulers@ for each @Core@
* *Stimuli Model*, containing the @Stimuli@ for the resp. @Runnable@ and @Task@ activations

h3(#sec:mapImplementation). Implementation

The following subsections give a short introduction about the different algorithm implementations of the OpenMapping Plugin. Section "Task generation":#sec:mapTaskGen describes the task generation method which is used to convert process prototypes into tasks. It is meant to be used by mapping algorithms which do not feature task generation by themselves. Sections "Mapping Strategy 1: Heuristic DFG load balancing":#sec:mapLoadBalDFG and "Mapping Strategy 2: ILP based load balancing":#sec:mapLoadBalILP describe a heuristic and a mathematical load balancing approach for mapping tasks to cores. Finally, a more complex method for energy efficient task mapping with its own task creation algorithm is outlined in section "Mapping Strategy 3: Minimizing Energy Consumption":#sec:mapEnergy.

h4(#sec:mapTaskGen). Task generation

The task generation method in OpenMapping Plugin is a pragmatic way to create tasks for other mapping algorithms which require @Tasks@, i.e. are not designed to agglomerate @Runnables@ into @Tasks@ on their own. This step utilizes @ProcessPrototypes@ which are generated by the partitioning plugin (see Chapter *Partitioning*) and transforms them into @Tasks@. Furthermore, it will also create the *_Stimuli Model_* which contains the activation elements for the @Tasks@, i.e. @Periodic@. An overview about the transformed elements and their sources as well as destinations is shown in "Table 1":#tab:table1.

p<(#tab:table1). 

|_. Source Model|_. Source Element|_. Target Model|_. Target Element|
| SW| ProcessPrototype| SW| Task|
| SW| Activation| Stimuli| Stimulus|
| Constraints| ProcessRunnableGroupEntry| SW| TaskRunnableCall|

p=. Table 1

h4(#sec:mapLoadBalDFG). Mapping Strategy 1: Heuristic DFG load balancing

The _Heuristic Data Flow Graph (DFG) load balancing_ algorithm aims at achieving an equal utilization of a hardware platforms cores for DFG based software models.

The first step in this algorithm is to determine the most complex @Task@ (usually representing the critical path) and allocate it to the best fit core of a hardware platform. The runtime for each @Task@ will now be estimated for every @Core@ within the @System@ and allocated to a @Core@ which has the smallest increase of the longest overall runtime within all cores.

One of the major benefits of this algorithm is its very low runtime. The information which is processed by this mapping strategy and, as such, has to be present in the input models, is shown in "Table 2":#tab:table2.


h4(#sec:mapLoadBalILP). Mapping Strategy 2: ILP based load balancing

This section described a comparatively simple ILP based strategy for allocating tasks to processors while minimizing the total execution time. This method supports multiple processors with the same processing speed (e.g. homogeneous processors) and it does not consider any dependencies between the tasks (e.g. waiting for the results of the predecessor).

Load balancing within this method is achieved by minimizing the highest execution duration _C_ _~max~_ of all _m_ processing units with _n_ tasks. The variable _x_ _~ij~_ is set to _1_ if a task _j_ is allocated to processor _i_ and _0_ otherwise. The model guarantees that each task is allocated to exactly one processor and limits the variables _x_ _~ij~_ type to boolean values. The duration (execution time) of a task _j_ is specified by _p_ _~j~_.

!{width:33.0%;height:auto;}../pictures/mapping/matheq.png(ILP notation for Load Balancing)!

One of the downsides in this algorithm is caused by variable _p_ _~j~_ which forces an equal processing duration of a task _j_ on all cores. It is however possible to expand the method to support heterogeneous processors (in this case: processors with different processing speeds) with a minor modification: replacing _p_ _~j~_ with _p_ _~ij~_, i.e. a separate processing duration of task _j_ for every core _i_, will solve this problem.

The minimal amount of information which is required to execute this algorithm is outlined in "Table 2":#tab:table2.

p<(#tab:table2). 

|_. Source Model|_. Element|_. Description|
|<. HW|<. @Core@|<. A @Core@ represents the target of an allocation, an OS Model with a @Scheduler@ for each @Core@ will be generated.|
|<. |<. @CoreType@ @Prescaler@ @Quartz@|<. A @Cores@ @Prescaler@, the referenced @Quartz@ and the @CoreTypes@ attribute @CyclesPerTick@ of a @Core@ are used to determine the number of processed @Instructions@ per second.|
|<. SW|<. @Task@|<. @Tasks@ will be allocated to a @Core@ (over the @Cores@ @Scheduler@)|
|<. |<. @Runnable@|<. @Runnables@ are derived from a @Tasks@ @TaskRunnableCalls@, their attribute @Instructions@ is used during the load calculation for each @Core@|
|<. Stimuli|<. @Stimulus@ (@Periodic@)|<. The @Periodic@ Stimulus is used to specify the @Tasks@ activation rate, i.e. the period between its calls|

p=. Table 2

h4(#sec:mapEnergy). Mapping Strategy 3: Minimizing Energy Consumption

This mapping algorithm is based on the work _"Task Scheduling and Voltage Selection for Energy Minimization"_ from Zhang et al. which presents a framework that aims at minimizing the energy consumption of variable voltage processors executing real time dependent tasks. This method is implemented as a two phase approach which integrates

* *Task assignment*: allocating each task to a core
* *Task ordering*: ordering the tasks in due consideration of their constraints and deadlines
* *Voltage selection*: selecting a slower but less energy consuming processor mode in order to save energy without harming any constraints or deadlines

In the first phase, opportunities for energy minimization are revealed by ordering real&#45;time dependent tasks and assigning them to processors on the respective target platform.

* On *single processor platforms*, the ordering of tasks is performed by applying an Earliest Deadline First (EDF) scheduling. An further allocation of tasks to processors becomes needless, as only one allocation target exists.
* On *multi processor platforms*, a priority based task ordering is performed. The allocation of tasks to processors is determined by a best fit processor assignment.

Once the scheduling is created, there will be time frames between the end of one task and the start of another during which the processor is not being utilized (so called slacks). These slacks the prerequisites for the second phase, which performs the voltage selection. This phase aims at determining the resp. (optimal) processor voltage for each of its task executions without harming the constraints and eventually minimizing the total energy consumption of the system. In order to determine these voltages, the task scheduling is transformed into a directed acyclic graph (DAG) that is used to model the selection problem as integer programming (IP) problem. Once the model has been set up, it is optimized by a mathematical solver.

This algorithm has been implemented with two constraints:

* Only multi&#45;core systems may be chosen as target platform, single core is not supported.
* The algorithm is not meant to be used on heterogeneous cores, i.e. only multiple instances of the same type of core are supported.

"Table 3":#tab:table3 lists the minimal amount of information which has to be present in the input models in order for this mapping strategy to work as well the special annotations which are added to the mapping model.

p<(#tab:table3). 

|_. Source Model|_. Element|_. Description|
|<. HW|<. @Core@|<. A @Core@ represents the target of an allocation, an OS Model with a @Scheduler@ for each @Core@ will be generated.|
|<. |<. @CoreType@ @Prescaler@ @Quartz@|<. A @Cores@ @Prescaler@, the referenced @Quartz@ and the @CoreTypes@ attribute @CyclesPerTick@ of a @Core@ are used to determine the number of processed @Instructions@ per second.|
|<. |<. |<. The @CoreTypes@ attributes (@DoubleValue@) starting with the label _EnEf&#45;Volt&#95;{SomeID}_ and _EnEf&#45;Scale&#95;{SomeID}_ are used to specify the voltage levels, i.e. the performance of a core during a specific voltage.|
|<. SW|<. @Runnable@|<. @Runnables@ will be distributed on the @Cores@ (over the @Cores@ @Scheduler@), their attribute @Instructions@ is used during the load calculation for each @Core@|
|<. |<. @Activation@ (@Periodic@)|<. The @Periodic@ activation specifies the recurrence of the @Runnable@. The lowest recurrence is used to specify the overall deadline of all @Runnables@, i.e. the max amount of time for the sum of all @Runnable@ executions.|
|<. Constraints|<. @Process-Runnable-Group@ @Runnable-Sequencing-Constraint@|<. Are used to determine the executional order of the @Runnables@ as well as their interdependencies|
|<. Mapping|<. @Runnable-Allocation@ @Custom-Property@ @LongValue@|<. Specifies the selected voltage level and the number of @ExecutionCycles@ at this voltage level.|

p=. Table 3

h3(#sec:mapUtilization). Utilization of the OpenMapping Plugin

This section provides information on the utilization of the AMALTHEA Mapping Plugin, i.e. its configuration (section "Configuration and Preferences":#sec:mapConfiguration ) and how to generate mappings (section "Generating a mapping":#sec:mapCreateMapping ).

h4(#sec:mapConfiguration). Configuration and Preferences

!{width:50.0%;height:auto;}../pictures/mapping/MappingPreferences.png(AMALTHEA Mapping Plugin's Preferences Page)!

The configuration of OpenMapping Plugin can be performed through its preferences page. It is integrated into APP4MC and can be accessed through the menu bar under 'Window' -> 'Preferences' -> 'AMALTHEA Mapping'. The configurable fields, their types and their descriptions are listed below.

h4(#enabling-verbose-logging). Enabling verbose logging

Checking the box *_'Enable verbose logging to console'_* will enable verbose logging to stdout. This may help to identify problems if the mapping plugin should fail to generate a mapping.

h4(#specifying-the-output-location). Specifying the output location

The radio buttons under *_'Select output location'_* allow to customize the directory which where newly generated files will be placed into.

* *Default location* specifies the 'output' directory within the respective projects root folder as destination for all new generated files.
* *Custom location (relative to project root)* will ensure that all new files are created in a custom directory of the respective projects root folder. The name of this custom directory can be customized by changing the value in the text field below the radio buttons.
* *Custom location (absolute path)* allows the user to specify a full custom destination for new generated files. The destination can be specified by either changing the value of the text field below the radio buttons, or by using the "Select" button.
_Hint: It should be noted, that using this option will NOT update the project explorers folder list once the mapping is finished. It should be avoided to use this option in combination with a target location within the eclipse workspace._

h4(#selecting-a-mapping-algorithm). Selecting a mapping algorithm

The radio buttons within *_'Select mapping algorithm'_* allow to customize the mapping strategy which should be applied during the mapping process. Currently, there are three valid options:

* *Load balancing for DFG*, described in section "Mapping Strategy 1: Heuristic DFG load balancing":#sec:mapLoadBalDFG
* *ILP based load balancing*, described in section "Mapping Strategy 2: ILP based load balancing":#sec:mapLoadBalILP
* *Energy efficient mapping*, described in section "Mapping Strategy 3: Minimizing Energy Consumption":#sec:mapEnergy

h4(#configuring-mathematical-solver). Configuring Mathematical Solver

_Hint: The settings described in this section only affect ILP based algorithms!_

The section *_Solver Settings_* allows to configure the solver which is used to approximate the ILP problems, specify the minimal accuracy of the found solution and activate the MPS file output of the &#45; ready to solve &#45; ILP problem.

* *Generate MPS file* will activate MPS file generation. The resulting MPS file will contain the actual ILP problem for the chosen mapping strategy.
* *Max. Gap* specifies the maximal gap (percentage) between the LP relaxion and a feasible solution before the solver considers it to be optimal.
Setting this value to 0.0 will order to solver to continue until either the final solution reaches the same value as the LP relaxion or another limit (below) has been reached while 1.0 will consider the first feasible solution being optimal.
_Valid values: <span class="math">0.0 - 1.0</span>_

Furthermore, it is possible to specify the maximum number of iterations or time spend on finding an optimal solution.

* *Max. Iterations (Abort)* specifies the maximal *_total_* number of iterations which may be performed by the approximation algorithm in order to find an optimal solution for the ILP problem.
* *Max. Time (Abort)* specifies the maximal *_total_* amount of time (milliseconds) that may be spend by the approximation algorithm in order to find an optimal solution for the ILP problem.
* *Max. Iteration (Suffice)* specifies the maximal number of iterations which may be performed by the approximation algorithm in order to *_improve_* a previously found feasible solution.
* *Max. Time (Suffice)* specifies the maximal amount of time (milliseconds) that may be spend by the approximation algorithm in order to *_improve_* a previously found feasible solution.

Setting one of these values to zero will pass the value of INT&#95;MAX to the solver, technically removing the respective constraint.

h4(#sec:mapCreateMapping). Generating a mapping

Depending on the selected mapping strategy, it may be required to create tasks in advance of the mapping algorithm. The method *'Create Tasks'*, which is accessible through the _AMALTHEA Software Models_ file context menu (right click on _*.amxmi_ and _*.amxmi&#45;sw_ files), is capable of transforming partitioned software models into software models with tasks.

The mapping can be performed once input models with the required amount of information are present. Opening the context menu again (right click on _*.amxmi_ and _*.amxmi&#45;sw_ files) and selecting *'Perform Mapping'* will open the 'Perform Mapping GUI'.

!{width:66.0%;height:auto;}../pictures/mapping/MappingGUI.png(Perform Mapping GUI)!

The fields within the GUI are described below.

* *Name of the Project* is automatically filled and based on the selected software model. This value is used to specify the base name of the output files and may be customized.
* *Path to Software Model* points to the location of the file containing the AMALTHEA Software Model which will be used during the mapping process. This path is automatically set, but may be changed if desired.
* *Path to Hardware Model* points to the location of the file containing the AMALTHEA Hardware Model which will be used during the mapping process.


fn1. Oj!Algorithms, licensed under the MIT license, see: http://ojalgo.org
