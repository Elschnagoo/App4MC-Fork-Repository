
h2. Model Details

h3. Unique ID generation

AMALTHEA uses a named based schema to reference other elements inside of a model.
A custom implementation is used instead of the standard EMF mechanism, which uses an index based implementation.
The target element id is identified by the following schema:

bc. 
java.net.URLEncoder.encode(<name of element>, StandardCharsets.UTF_8.toString)) + "?type=" + <element>.eClass.name

Samples:

Referencing a Runnable element with name foo in a TaskRunnableCall looks like the following snippet:

bc. 
<calls xsi:type="am:TaskRunnableCall" runnable="foo?type=Runnable" />


h3. Interfaces and base objects

Several interfaces and abstract classes are defined in the common model.
They provide basic common functionality for all objects, which are extending it, like the possibility to add __CustomAttributes__ or __Tags__. Tags are available at different elements with the purpose to group them together or to annotate them.

!(scale)../pictures/model_common_interfaces_base_objects.png!


h3. Transient back pointers

AMALTHEA maintains a (small) number of back pointers in the model. A transient reference of an object 'points back' to the object referring to it. This allows easier navigation, at the expense of greater memory use.

h4. Current back pointers

TODO Some text to explain the intermediate objects LabelAccess and RunnableCall.
They are contained objects

| | Back pointer (read only) |>. Reference | |
| @LabelAccess@ |{color:green}. &#8592; *labelAccesses* |>. *data* &#8594; | @Label@ |
| @TaskRunnableCall@ |{color:green}. &#8592; *taskRunnableCalls* |>. *runnable* &#8594; | @Runnable@ |
| @RunnableCall@ |{color:green}. &#8592; *runnableCalls* |>. *runnable* &#8594; | @Runnable@ |

TODO Some text to explain mapping.

| | Back pointer (read only) |>. Reference | |
| @Mapping@ |{color:green}. &#8592; *mappings* |>. *memory* &#8594; | @Memory@ |
| @AbstractElementMapping@ |{color:green}. &#8592; *mappings* |>. *abstractElement* &#8594; | @AbstractElementMemoryInformation@ |

TODO Some text to explain sections.

| | Back pointer (read only) |>. Reference | |
| @Label@ |{color:green}. &#8592; *labels* |>. *section* &#8594; | @Section@ |
| @Runnable@ |{color:green}. &#8592; *runnables* |>. *section* &#8594; | @Section@ |

h4. Implementation

**Xcore:**

In addition to a reference %*&lt;reference&gt;*% there is a transient reference named  %*&lt;reference&gt;LinkInt*%.
The visiblity in the generated code and in the user interface is controlled by %*@GenModel*% annotations.

bc.. 
class TaskRunnableCall extends CallSequenceItem
{	...
	refers Runnable[1] runnable
	
	// hidden link (internal)
	@GenModel(property="None", suppressedGetVisibility="true", suppressedSetVisibility="true"))
	refers transient Runnable[1] runnableLinkInt opposite taskRunnableCalls
}

class Runnable extends AbstractElementMemoryInformation
{	...	
	// back pointer (readonly)
	@GenModel(property="Readonly", suppressedSetVisibility="true")
	@GenModel(propertyCategory="Read only", propertyFilterFlags="org.eclipse.ui.views.properties.expert")
	refers transient TaskRunnableCall[] taskRunnableCalls opposite runnableLinkInt 
}
p. 

**Classes and references:**

!../pictures/impl/model_transient_backpointer.png!

**Generated code:**

EMF code generation allows the use of dynamic templates. AMALTHEA uses this technology to additionally set the transient value in the  setter code of the standard value. The dynamic template is triggered by the name pattern %'&lt;reference&gt;%' and %'&lt;reference&gt;LinkInt'%.

bc.. 
public class TaskRunnableCallImpl ... {
	...
	public void setRunnable(org.eclipse.app4mc.amalthea.model.Runnable newRunnable) {
		...
 		//Additional setting transient value for transient bi-directional reference
 		setRunnableLinkInt(newRunnable);
	}
}
p. 

h4. User Interface

!../pictures/impl/model_transient_backpointer_ui.png!
