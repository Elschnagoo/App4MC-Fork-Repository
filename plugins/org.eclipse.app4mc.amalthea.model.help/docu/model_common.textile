
h2. Common Model

The AMALTHEA common model is not a model by itself, but provides standard elements used by other models as containments.


h3. Common Elements

The only exception is the __CommonElements__ class that provides a central container for tags and classifiers. These elements are used in many sub models where references to tags or classifiers provide a mechanism to annotate the objects.

!../pictures/model_common_elements.png!


h3(#common-tags). Tags

Tags are a generic possibility to annotate objects in the AMALTHEA model.

!../pictures/model_common_tag.png!


h3(#common-classifiers). Classifiers

Classifiers are used to define specific features or abilities of a core or a memory. They are used in the __PropertyConstraintsModel__ to restrict the allocation to cores or the memory mapping.

!../pictures/model_common_classifier.png!


h3(#common-custom-props). Custom Properties

The __CustomProperty__ element is used to define own properties that are not (yet) available in AMALTHEA. If there is the need to extend an element or to store tool information related to processing steps, __CustomProperties__ can be used to store this type of information. It also provides the possibility to work with prototypical approaches that later (if established and more stable) can be integrated in the standard model.

!../pictures/model_common_custom_property.png!

The elements are stored in a __HashMap__. The values can be of different types as shown in the structure picture, like String, Integer, Boolean...
In addition a __ReferenceObject__ is available to store own references to other __EObject__ elements.
The __ListObject__ can be used to store multi-valued custom properties.

!(scale)../pictures/model_common_custom_property_value.png!


h3. Time (and Time Unit)

The AMALTHEA data model includes a common element to describe time ranges in an easy way, the __Time__ element. The __Time__ class in general allows to define negative time values. If only positive values are expected the AMALTHEA validation will show a warning.
The __Time__ element can be referred by any other element for specifying attributes to store time information.
Time units are needed to describe different timing behavior and requirements, like deadlines or offsets of components.
To support different time ranges, especially different time units, AMALTHEA predefines these types like seconds, milli-seconds, micro-seconds,  nano-seconds or pico-seconds.

!(scale)../pictures/model_common_time.png!


h3. Frequency (and Frequency Unit)

!(scale)../pictures/model_common_frequency.png!


h3. Data Size (and Data Size Unit)

The  __DataSize__ (and  __DataRate__) definition contains units and prefixes
* according to the SI Standard
* for binary multiples
 <table>
 <tr>
 <th style="padding:15px">International System of Units (SI)</th>
 <th style="padding:15px">Prefixes for binary multiples</th>
 </tr>
 <tr>
 <td style="vertical-align:top; padding:15px"> 
table(classic). 
| _*Name*_ | _*Prefix*_ | _*Factor*_ |
| kilo | k | 10<sup>3</sup> |
| mega | M | 10<sup>6</sup> |
| giga | G | 10<sup>9</sup> |
| tera | T | 10<sup>12</sup> |
| _peta_ | _P_ | _10<sup>15</sup>_ |
 </td>
 <td style="vertical-align:top; padding:15px"> 
table(classic). 
| _*Name*_ | _*Prefix*_ | _*Factor*_ |
| kibi | Ki | 2<sup>10</sup> |
| mebi | Mi | 2<sup>20</sup> |
| gibi | Gi | 2<sup>30</sup> |
| tebi | Ti | 2<sup>40</sup> |
| pebi | Pi | 2<sup>50</sup> |
| _exbi_ | _Ei_ | _2<sup>60</sup>_ |
 </td>
 </tr>
 </table>

The __DataSize__ provides convenience methods to get the size also in bit and byte.
It is internally converted and can be retrieved in both ways.

!(scale)../pictures/model_common_data_size.png! 


h3. Data Rate (and Data Rate Unit)

!(scale)../pictures/model_common_data_rate.png! 


h3. Deviation

The __Deviation__ class is used to model statistical distributions within AMALTHEA. There is a wide variety of possible use cases, where such a distribution is needed. With such a deviation for example, the variation in run times of functions or respectively their instructions can be imitated. Therefore, AMALTHEA currently supports the following three statistical distributions:

!(scale)../pictures/model_common_deviation.png!

h4. Boundaries

With the __Boundaries__ class it is possible to define the deviation of instructions in such a way that a specific scenario is covered. The scenario is on the one hand specified by the minimum and maximum value between which the instructions vary. On the other hand, the __Sampling Type__ specifies the specific scenario that is covered. The following sampling types are available which are visualised in the figures below:

- BestCase := Defines the scenario in which most instances should have runtimes close to the set minimum runtime, but still should consider some more time-consuming outliers up to the set maximum.
- WorstCase := Defines the scenario in which most instances should have runtimes close to the set maximum runtime, but still should consider some less time-consuming outliers down to the set minimum.
- AverageCase := Defines the scenario in which most instances should have runtimes close to the middle between the set minimum and maximum, but still should consider some less and more time-consuming outliers down to the set minimum or up to the set maximum respectively. 
- CornerCase := Defines the scenario in which most instances should have runtimes close to the set minimum and maximum runtime, but still should consider some other time-consuming outliers between those two.
- Uniform := Defines the scenario in which all instances should have runtimes that are uniformly distributed between the set minimum and maximum.

!../pictures/model_common_deviation_boundaries_1.png!

!../pictures/model_common_deviation_boundaries_2.png!


h4. Uniform Distribution

The uniform distribution is a statistical distribution where the values between the stated lower and upper bound are equally likely to be observed.

!../pictures/model_common_deviation_uniform.png!

h4. Gaussian/Normal Distribution

The Gaussian/normal distribution is a statistical distribution where the values decrease symmetrically. The maximum value and thus its location is thereby stated by the mean and the rate of decrease is defined by its standard deviation. Since the curves approach zero on either side, an additional upper and lower bound can be added to constraint the values.

!../pictures/model_common_deviation_normal.png!

h4. Beta Distribution

The Beta distribution is a statistical distribution whose shape is defined by alpha > 0 and beta > 0. That way, the Beta distribution can also be used to model other distributions like for example uniform, normal, or Bernoulli distribution. Since the curves can approach zero or infinity on either side, an additional upper and lower bound can be added to constraint the values.

!../pictures/model_common_deviation_beta.png!

h4. Weibull Distribution

The Weibull distribution is a statistical distribution whose shape is defined by kappa > 0 and the scale of the distribution by lambda > 0. That way, the Weibull distribution can also be used to model other distributions like for example the exponential or normal distribution. Since the curves can approach zero or infinity on either side, an additional upper and lower bound can be added to constraint the values. Alternatively, the Weibull distribution can also be parameterized using the mean value and a parameter that constraints the distribution regarding the per mill of remaining values.

!../pictures/model_common_deviation_weibull.png!

h3. Statistic Elements

The contained elements are representing statistical values.
The values can be set either with a min, avg and max representation using the __MinAvgMaxStatistic__ element.
The other possibility is to set a single value using the __SingleValueStatistic__ element.
The minimum and maximum values are set as a normal __int__ value,  the average the single value as __float__.

!../pictures/model_common_statistic.png!



h3. Instructions

Instructions are used to express execution times in a more abstract way. The number of instructions characterizes the amount of computation that is necessary to execute e.g. a __Runnable__. Depending on the capabilities of a __Core__ (the frequency and the instructions per cycle) the time to execute such an element will differ.

In the next picture a more detailed overview is given about the __Instructions__.

!../pictures/model_common_instructions.png!

table(minimal){padding:10px; border:1px solid black; background:#f8f8f8}. 
|_. Name |_. Description |
| __Instructions__| As a runnable contains several instructions to perform, this is represented using different algorithms or a constant value to consume the same amount of time/ticks per cycle.|


h3. Counters

The __Counter__ element describes an activation of a target element that happens only every n<sup>th</sup> time.

table(minimal){padding:10px; border:1px solid black; background:#f8f8f8}. 
|_. Name |_. Description |
| __prescaler__ | Gives the number n for the activation,<br/>e.g. if set to 2, the target element is executed every second time. |
| __offset__ | Initial shift for the first execution of the target. |

If for example __prescaler__ is 5 and __offset__ is 2 it is executed on the 2<sup>nd</sup>, 7<sup>th</sup>, 12<sup>th</sup>, â€¦ time.

Counters are available at the following elements:

* Call sequence items:
** __ClearEvent__
** __EnforcedMigration__
** __InterProcessActivation__
** __SchedulePoint__
** __SetEvent__
** __TaskRunnableCall__
** __TerminateProcess__
** __WaitEvent__
* Stimuli:
** __InterProcess__
** __EventStimulus__


